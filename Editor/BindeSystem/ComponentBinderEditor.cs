using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEngine;

namespace ComponentBinder
{
    /// <summary>
    /// 通用的组件绑定编辑器，可以用于任何MonoBehaviour脚本
    /// 使用方法：通过UniversalComponentBinder调用，避免与其他Editor冲突
    /// </summary>
    public class ComponentBinderEditor
    {
        private MonoBehaviour targetScript;
        private SerializedObject serializedTarget;

        private List<DragTargetEntry> dragTargets = new();
        private Dictionary<DragTargetEntry, string> renameMap = new();
        private Dictionary<DragTargetEntry, List<Component>> componentMap = new();
        private Dictionary<DragTargetEntry, int> selectedIndices = new();
        private Dictionary<DragTargetEntry, bool> fieldVisibilityMap = new Dictionary<DragTargetEntry, bool>(); // 每个字段的可见性设置
        private HashSet<string> cachedExistingFields = new HashSet<string>();
        
        // 命名空间管理
        private string currentNamespace = "";
        private List<string> savedNamespaces = new List<string>();
        private const string NAMESPACE_PREFS_KEY = "ComponentBinder_SavedNamespaces_";
        private bool applyNamespaceOnGenerate = false;

        // 自动获取功能
        private List<string> availableComponentTypes = new List<string>();
        private int selectedTypeMask = 0;
        private bool isAutoFetchExpanded = true;
        private bool foldout = false;
        private bool useSeparateScript = false; // 是否使用分离脚本模式

        public ComponentBinderEditor(MonoBehaviour target)
        {
            targetScript = target;
            serializedTarget = new SerializedObject(targetScript);
            
            // 初始化集合
            dragTargets = new List<DragTargetEntry>();
            renameMap = new Dictionary<DragTargetEntry, string>();
            componentMap = new Dictionary<DragTargetEntry, List<Component>>();
            selectedIndices = new Dictionary<DragTargetEntry, int>();
            fieldVisibilityMap = new Dictionary<DragTargetEntry, bool>();
            
            CacheExistingFields();
            LoadNamespace();
            LoadExistingAutoGeneratedFields();
        }

        /// <summary>
        /// 通知Inspector需要重绘
        /// </summary>
        private void RequestRepaint()
        {
            if (targetScript != null)
            {
                EditorUtility.SetDirty(targetScript);
                // 通过EditorApplication来触发重绘
                EditorApplication.QueuePlayerLoopUpdate();
            }
        }

        public void DrawComponentBinderInspector()
        {
            serializedTarget.Update();

            EditorGUILayout.Space();
            foldout = EditorGUILayout.BeginFoldoutHeaderGroup(foldout, "组件自动绑定");
            if (foldout)
            {
                DrawNamespaceArea();
                DrawAutoFetchArea();
                DrawSettings();
                DrawDragArea();
                DrawRenameFields();

                if (GUILayout.Button("生成组件字段"))
                {
                    // 只有在没有现有区域且列表为空时才阻止生成
                    // 这样允许用户清空列表后点击生成来清除所有绑定
                    if (dragTargets.Count == 0 && !HasAutoGeneratedRegion(targetScript))
                    {
                        EditorUtility.DisplayDialog("提示", "请先拖拽需要绑定的对象", "确定");
                        return;
                    }

                    if (useSeparateScript)
                    {
                        CreateSeparateComponentHolder();
                    }
                    else
                    {
                        ApplyComponentAutoBindings();
                    }
                    ApplyNameChanges();
                    SaveNamespace();
                }
            }
            EditorGUILayout.EndFoldoutHeaderGroup();

            EditorGUILayout.Space();
        }

        /// <summary>
        /// 检查脚本是否包含AutoGenerated区域
        /// </summary>
        public static bool HasAutoGeneratedRegion(MonoBehaviour target)
        {
            var script = MonoScript.FromMonoBehaviour(target);
            if (script != null)
            {
                string scriptPath = AssetDatabase.GetAssetPath(script);
                if (System.IO.File.Exists(scriptPath))
                {
                    string[] lines = System.IO.File.ReadAllLines(scriptPath);
                    return lines.Any(line => line.Contains("#region AutoGenerated"));
                }
            }
            return false;
        }

        private void DrawNamespaceArea()
        {
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("命名空间管理:", EditorStyles.boldLabel);
            
            EditorGUILayout.BeginHorizontal();
            
            applyNamespaceOnGenerate = EditorGUILayout.ToggleLeft("生成时修改", applyNamespaceOnGenerate, GUILayout.Width(85));
            
            EditorGUILayout.LabelField("Namespace:", GUILayout.Width(75));
            
            string newNamespace = EditorGUILayout.TextField(currentNamespace);
            if (newNamespace != currentNamespace)
            {
                currentNamespace = newNamespace;
            }
            
            if (savedNamespaces.Count > 0)
            {
                int selectedIndex = -1;
                var options = new List<string> { "Select..." };
                options.AddRange(savedNamespaces);
                
                int newIndex = EditorGUILayout.Popup(selectedIndex + 1, options.ToArray(), GUILayout.Width(80));
                if (newIndex > 0)
                {
                    currentNamespace = savedNamespaces[newIndex - 1];
                    GUI.FocusControl(null); // 移除焦点以更新文本框
                }
            }
            
            if (GUILayout.Button("立即修改", GUILayout.Width(70)))
            {
                ExecuteNamespaceUpdate();
            }
            
            EditorGUILayout.EndHorizontal();
        }

        private void ExecuteNamespaceUpdate()
        {
            string scriptPath = AssetDatabase.GetAssetPath(MonoScript.FromMonoBehaviour(targetScript));
            if (!File.Exists(scriptPath)) return;
            
            var lines = File.ReadAllLines(scriptPath).ToList();
            UpdateNamespace(lines);
            File.WriteAllLines(scriptPath, lines);
            AssetDatabase.Refresh();
            SaveNamespace();
            EditorUtility.DisplayDialog("提示", "命名空间已更新", "确定");
        }



        private void DrawAutoFetchArea()
        {
            EditorGUILayout.Space();
            isAutoFetchExpanded = EditorGUILayout.Foldout(isAutoFetchExpanded, "自动获取组件:", true);
            if (!isAutoFetchExpanded) return;

            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            
            // 1. 获取全部子对象
            if (GUILayout.Button("自动获取全部子对象"))
            {
                FetchChildren(false);
            }

            EditorGUILayout.Space();

            // 2. 获取指定类型
            EditorGUILayout.LabelField("按类型获取:", EditorStyles.boldLabel);
            
            // 更新可用组件类型列表
            if (availableComponentTypes.Count == 0)
            {
                UpdateAvailableComponentTypes();
            }

            // 绘制多选下拉框
            if (availableComponentTypes.Count > 0)
            {
                selectedTypeMask = EditorGUILayout.MaskField("选择组件类型", selectedTypeMask, availableComponentTypes.ToArray());
                
                if (GUILayout.Button("自动获取指定类型对象"))
                {
                    FetchChildren(true);
                }
            }
            else
            {
                EditorGUILayout.HelpBox("没有在子对象中找到可绑定的组件。", MessageType.Info);
                if (GUILayout.Button("刷新组件列表"))
                {
                    UpdateAvailableComponentTypes();
                }
            }

            EditorGUILayout.EndVertical();
        }

        private void UpdateAvailableComponentTypes()
        {
            availableComponentTypes.Clear();
            var allComponents = targetScript.GetComponentsInChildren<Component>(true);
            var types = new HashSet<string>();
            
            foreach (var comp in allComponents)
            {
                if (comp == null || comp == targetScript) continue;
                // 排除 Transform，因为几乎所有对象都有，没必要特意筛选
                if (comp is Transform) continue;
                
                string typeName = comp.GetType().Name;
                if (typeName.Contains("TextMeshPro")) typeName = "TMP_Text"; // 统一 TMP 名称
                
                types.Add(typeName);
            }
            
            availableComponentTypes = types.OrderBy(t => t).ToList();
        }

        private void FetchChildren(bool specificTypes)
        {
            var allTransforms = targetScript.GetComponentsInChildren<Transform>(true);
            int addedCount = 0;
            
            // 解析选中的类型
            var selectedTypes = new HashSet<string>();
            if (specificTypes)
            {
                for (int i = 0; i < availableComponentTypes.Count; i++)
                {
                    if ((selectedTypeMask & (1 << i)) != 0)
                    {
                        selectedTypes.Add(availableComponentTypes[i]);
                    }
                }
                
                if (selectedTypes.Count == 0)
                {
                    EditorUtility.DisplayDialog("提示", "请先选择至少一种组件类型。", "确定");
                    return;
                }
            }

            foreach (var t in allTransforms)
            {
                if (t.gameObject == targetScript.gameObject) continue;
                
                // 检查是否已经存在
                if (dragTargets.Any(entry => entry.gameObject == t.gameObject)) continue;
                
                bool shouldAdd = false;
                string targetTypeName = "GameObject"; // 默认类型

                if (!specificTypes)
                {
                    // 获取全部模式：只要是子对象就添加
                    shouldAdd = true;
                    // 尝试智能推断类型
                    var comps = t.GetComponents<Component>();
                    var bestComp = comps.Where(c => c != null && !(c is Transform))
                                      .OrderBy(GetComponentPriority)
                                      .FirstOrDefault();
                    
                    if (bestComp != null)
                    {
                        targetTypeName = bestComp.GetType().Name;
                        if (targetTypeName.Contains("TextMeshPro")) targetTypeName = "TMP_Text";
                    }
                }
                else
                {
                    // 指定类型模式：检查是否包含选中的类型
                    var comps = t.GetComponents<Component>();
                    
                    // 找到所有匹配的组件
                    var matchingComps = comps.Where(c => 
                    {
                        if (c == null) return false;
                        string typeName = c.GetType().Name;
                        if (typeName.Contains("TextMeshPro")) typeName = "TMP_Text";
                        return selectedTypes.Contains(typeName);
                    }).ToList();

                    if (matchingComps.Count > 0)
                    {
                        shouldAdd = true;
                        // 冲突解决：如果有多个匹配类型，选择优先级最高的
                        var bestComp = matchingComps.OrderBy(GetComponentPriority).FirstOrDefault();
                        if (bestComp != null)
                        {
                            targetTypeName = bestComp.GetType().Name;
                            if (targetTypeName.Contains("TextMeshPro")) targetTypeName = "TMP_Text";
                        }
                    }
                }

                if (shouldAdd)
                {
                    AddGameObjectToLists(t.gameObject, targetTypeName, false);
                    addedCount++;
                }
            }
            
            if (addedCount > 0)
            {
                RequestRepaint();
                Debug.Log($"自动获取了 {addedCount} 个对象。");
            }
            else
            {
                EditorUtility.DisplayDialog("提示", "没有发现新的可绑定对象。", "确定");
            }
        }

        private void LoadNamespace()
        {
            string scriptPath = AssetDatabase.GetAssetPath(MonoScript.FromMonoBehaviour(targetScript));
            if (!File.Exists(scriptPath)) return;
            
            string[] lines = File.ReadAllLines(scriptPath);
            foreach (var line in lines)
            {
                var match = Regex.Match(line, @"^\s*namespace\s+(\S+)");
                if (match.Success)
                {
                    currentNamespace = match.Groups[1].Value;
                    break;
                }
            }
            
            // 加载保存的命名空间
            string projectKey = NAMESPACE_PREFS_KEY + Application.productName;
            string savedJson = EditorPrefs.GetString(projectKey, "");
            if (!string.IsNullOrEmpty(savedJson))
            {
                savedNamespaces = new List<string>(savedJson.Split(';'));
            }
        }

        private void SaveNamespace()
        {
            if (string.IsNullOrEmpty(currentNamespace)) return;
            
            if (!savedNamespaces.Contains(currentNamespace))
            {
                savedNamespaces.Add(currentNamespace);
                string projectKey = NAMESPACE_PREFS_KEY + Application.productName;
                EditorPrefs.SetString(projectKey, string.Join(";", savedNamespaces));
            }
        }

        private void DrawSettings()
        {
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("设置:", EditorStyles.boldLabel);
            
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("生成模式:", GUILayout.Width(120));
            bool newUseSeparateScript = EditorGUILayout.Toggle("分离脚本", useSeparateScript, GUILayout.Width(100));
            
            // 如果模式发生了变化，重新加载字段
            if (newUseSeparateScript != useSeparateScript)
            {
                useSeparateScript = newUseSeparateScript;
                // 清空当前列表并重新加载
                dragTargets.Clear();
                renameMap.Clear();
                componentMap.Clear();
                selectedIndices.Clear();
                fieldVisibilityMap.Clear();
                LoadExistingAutoGeneratedFields();
            }
            EditorGUILayout.EndHorizontal();
            
            if (useSeparateScript)
            {
                EditorGUILayout.HelpBox("分离脚本模式: 将创建一个新的partial类文件来保存所有组件引用。", MessageType.Info);
            }
            else
            {
                EditorGUILayout.HelpBox("内联模式: 将直接在当前脚本的AutoGenerated区域中添加字段。", MessageType.Info);
            }
            
            EditorGUILayout.Space();
        }

        private void DrawDragArea()
        {
            Rect dropArea = GUILayoutUtility.GetRect(0f, 40f, GUILayout.ExpandWidth(true));
            GUI.Box(dropArea, "拖拽游戏对象到这里来绑定组件", EditorStyles.helpBox);

            Event evt = Event.current;
            if ((evt.type == EventType.DragUpdated || evt.type == EventType.DragPerform) && dropArea.Contains(evt.mousePosition))
            {
                DragAndDrop.visualMode = DragAndDropVisualMode.Copy;

                if (evt.type == EventType.DragPerform)
                {
                    DragAndDrop.AcceptDrag();
                                         foreach (var obj in DragAndDrop.objectReferences)
                     {
                         if (obj is GameObject go)
                         {
                             // 计算这个对象已经有多少个条目
                             int existingCount = dragTargets.Count(entry => entry.gameObject == go);
                             
                             // 创建新的条目
                             var newEntry = new DragTargetEntry(go, existingCount);
                             dragTargets.Add(newEntry);
                             
                             if (!renameMap.ContainsKey(newEntry))
                                 renameMap[newEntry] = ToPascalCase(go.name);

                             var comps = go.GetComponents<Component>().Where(c => c != null).ToList();
                             if (!comps.Any(c => c is Transform))
                                 comps.Add(go.transform);
                             comps.Add(new GameObjectProxy(go));

// 使用新方法进行排序
componentMap[newEntry] = comps.OrderBy(GetComponentPriority).ToList();



                             selectedIndices[newEntry] = 0;
                             fieldVisibilityMap[newEntry] = false; // 默认私有
                         }
                     }
                    GUI.FocusControl(null);
                    RequestRepaint();
                }
                evt.Use();
            }
        }

        private void DrawRenameFields()
        {
            var visibleTargets = dragTargets.ToList();
            if (visibleTargets.Count() == 0) return;

            EditorGUILayout.Space();
            EditorGUILayout.LabelField("对象列表:", EditorStyles.boldLabel);

            foreach (var entry in visibleTargets)
            {
                if (entry == null || entry.gameObject == null || !renameMap.ContainsKey(entry)) continue;

                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.ObjectField(entry.gameObject, typeof(GameObject), true, GUILayout.Width(120));

                // 添加字段可见性选择（在命名之前）
                bool isPublic = fieldVisibilityMap.ContainsKey(entry) ? fieldVisibilityMap[entry] : false;
                string[] visibilityOptions = { "私有", "公开" };
                int visibilityIndex = isPublic ? 1 : 0;
                visibilityIndex = EditorGUILayout.Popup(visibilityIndex, visibilityOptions, GUILayout.Width(50));
                fieldVisibilityMap[entry] = visibilityIndex == 1;

                var components = componentMap[entry];
                var names = components.Select(c =>
                {
                    if (c is GameObjectProxy) return "GameObject";
                    return c.GetType().Name;
                }).ToArray();
                selectedIndices[entry] = EditorGUILayout.Popup(selectedIndices[entry], names, GUILayout.Width(110));

                renameMap[entry] = EditorGUILayout.TextField(renameMap[entry]);

                GUI.backgroundColor = Color.red;
                if (GUILayout.Button("X", GUILayout.Width(20)))
                {
                    renameMap.Remove(entry);
                    dragTargets.Remove(entry);
                    componentMap.Remove(entry);
                    selectedIndices.Remove(entry);
                    fieldVisibilityMap.Remove(entry);
                    GUI.backgroundColor = Color.white;
                    RequestRepaint();
                    break;
                }
                GUI.backgroundColor = Color.white;
                EditorGUILayout.EndHorizontal();
            }
        }

        private void ApplyNameChanges()
        {
            foreach (var pair in renameMap)
            {
                GameObject go = pair.Key.gameObject;
                string newPascal = ToPascalCase(pair.Value);
                if (!string.IsNullOrEmpty(newPascal))
                {
                    Undo.RecordObject(go, "Change name");
                    go.name = newPascal;
                    EditorUtility.SetDirty(go);
                }
            }
        }

        private void ApplyComponentAutoBindings()
        {
            string scriptPath = AssetDatabase.GetAssetPath(MonoScript.FromMonoBehaviour(targetScript));
            string[] lines = File.ReadAllLines(scriptPath);
            var fieldLines = new List<string>(lines);

            int regionStart = fieldLines.FindIndex(line => line.Contains("#region AutoGenerated"));
            int regionEnd = fieldLines.FindIndex(line => line.Contains("#endregion"));

            // 清除现有的 AutoGenerated 区域
            if (regionStart != -1 && regionEnd != -1 && regionEnd > regionStart)
            {
                fieldLines.RemoveRange(regionStart, regionEnd - regionStart + 1);
            }

            // 重新生成字段列表
            List<string> newFields = new() { "    #region AutoGenerated" };
            cachedExistingFields.Clear();

            var pendingList = new AutoBindingEntryList();

            // 使用索引来遍历，这样可以保持顺序并处理重复的对象
            for (int i = 0; i < dragTargets.Count(); i++)
            {
                var entry = dragTargets[i];
                string baseName = renameMap.ContainsKey(entry) ? renameMap[entry] : entry.gameObject.name;
                string camelName = Char.ToLowerInvariant(baseName[0]) + baseName.Substring(1);
                var targetsToBind = new List<Component> { componentMap[entry][selectedIndices[entry]] };

                                 string varName;
                 foreach (var comp in targetsToBind)
                 {
                     if (comp is GameObjectProxy proxy)
                     {
                         // if (proxy.gameObjectRef == targetScript.gameObject) continue;

                         // 使用 对象名_组件名 的命名策略
                         varName = camelName + "_GameObject";

                         // 如果还是冲突，添加数字后缀
                         int suffix1 = 1;
                         string originalVarName1 = varName;
                         while (cachedExistingFields.Contains(varName))
                         {
                             varName = originalVarName1 + suffix1.ToString();
                             suffix1++;
                         }

                         bool isPublic1 = fieldVisibilityMap.ContainsKey(entry) ? fieldVisibilityMap[entry] : false;
                         string visibility1 = isPublic1 ? "public" : "private";
                         string attribute1 = isPublic1 ? "" : "[SerializeField] ";
                         newFields.Add($"    {attribute1}{visibility1} GameObject {varName};");
                         cachedExistingFields.Add(varName);

                         pendingList.list.Add(new AutoBindingEntry
                         {
                             scriptPath = scriptPath,
                             fieldName = varName,
                             targetInstanceId = targetScript.GetInstanceID(),
                             componentInstanceId = proxy.gameObjectRef.GetInstanceID()
                         });

                         continue;
                     }

                     if (comp == null) continue;

                     string typeName = comp.GetType().Name.Contains("TextMeshProUGUI") ? "TMP_Text" : comp.GetType().Name.Replace("Proxy", "");
                 
                     // 使用 对象名_组件名 的命名策略
                      varName=  GenerateFinalFieldName(camelName, typeName, cachedExistingFields);
                     /*varName = camelName + "_" + typeName;

                     // 如果还是冲突，添加数字后缀
                     int suffix = 1;
                     string originalVarName = varName;
                     while (cachedExistingFields.Contains(varName))
                     {
                         varName = originalVarName + suffix.ToString();
                         suffix++;
                     }*/

                     bool isPublic = fieldVisibilityMap.ContainsKey(entry) ? fieldVisibilityMap[entry] : false;
                     string visibility = isPublic ? "public" : "private";
                     string attribute = isPublic ? "" : "[SerializeField] ";
                     newFields.Add($"    {attribute}{visibility} {typeName} {varName};");
                     cachedExistingFields.Add(varName);

                     pendingList.list.Add(new AutoBindingEntry
                     {
                         scriptPath = scriptPath,
                         fieldName = varName,
                         targetInstanceId = targetScript.GetInstanceID(),
                         componentInstanceId = comp.GetInstanceID()
                     });
                 }
            }

            newFields.Add("    #endregion");

            string newRegion = string.Join("\n", newFields);
            string oldRegion = regionStart != -1 && regionEnd != -1 ? string.Join("\n", lines.Skip(regionStart).Take(regionEnd - regionStart + 1)) : "";

            if (oldRegion == newRegion)
            {
                Debug.Log("No changes detected");
                return;
            }

            int insertIndex = fieldLines.FindIndex(l => l.Contains("class") && l.Contains(":"));
            if (insertIndex != -1)
            {
                insertIndex++;
                            while (insertIndex < fieldLines.Count() && !fieldLines[insertIndex].Contains("{"))
                insertIndex++;
                fieldLines.InsertRange(insertIndex + 1, newFields);
            }

            // 自动添加必要的 using 语句
            AddRequiredUsingStatements(fieldLines, newFields);

            // 更新命名空间
            if (applyNamespaceOnGenerate)
            {
                UpdateNamespace(fieldLines);
            }

            File.WriteAllLines(scriptPath, fieldLines);
            EditorPrefs.SetString("ComponentBinder_AutoBindings", JsonUtility.ToJson(pendingList));
            AssetDatabase.Refresh();
        }

        private void CacheExistingFields()
        {
            string scriptPath = AssetDatabase.GetAssetPath(MonoScript.FromMonoBehaviour(targetScript));
            string[] lines = File.ReadAllLines(scriptPath);

            foreach (var line in lines)
            {
                var match = Regex.Match(line, @"private\s+(\S+)\s+(\S+);");
                if (match.Success)
                {
                    string varName = match.Groups[2].Value.TrimEnd(';');
                    cachedExistingFields.Add(varName);
                }
            }
        }

        private void LoadExistingAutoGeneratedFields()
        {
            if (useSeparateScript)
            {
                LoadSeparateScriptFields();
            }
            else
            {
                LoadInlineFields();
            }
        }
        
                 private void LoadInlineFields()
         {
             string scriptPath = AssetDatabase.GetAssetPath(MonoScript.FromMonoBehaviour(targetScript));
             if (!File.Exists(scriptPath)) return;
             
             string[] lines = File.ReadAllLines(scriptPath);
             int regionStart = Array.FindIndex(lines, line => line.Contains("#region AutoGenerated"));
             int regionEnd = Array.FindIndex(lines, line => line.Contains("#endregion"));
             
             if (regionStart == -1 || regionEnd == -1 || regionEnd <= regionStart) return;
             
             var debugInfo = new System.Text.StringBuilder();
             debugInfo.AppendLine($"[ComponentBinder] Loading inline fields from {scriptPath}");
             
             // 获取当前脚本的 SerializedObject 来读取引用关系
             var serializedObject = new SerializedObject(targetScript);
             
             // 先统计每个对象有多少个字段，用于正确分配索引
             var objectFieldCounts = new Dictionary<GameObject, int>();
             
             // 第一遍：统计每个对象的字段数量
             for (int i = regionStart + 1; i < regionEnd; i++)
             {
                 string line = lines[i].Trim();
                 if (string.IsNullOrEmpty(line)) continue;
                 
                 var fieldMatch = Regex.Match(line, @"(?:\[SerializeField\]\s+)?(public|private)\s+(\S+)\s+(\S+);");
                 if (fieldMatch.Success)
                 {
                     string typeName = fieldMatch.Groups[2].Value;
                     string fieldName = fieldMatch.Groups[3].Value;
                     
                     debugInfo.AppendLine($"[ComponentBinder] Found field: {typeName} {fieldName}");
                     
                     // 优先通过 SerializedProperty 获取引用关系
                     GameObject foundObject = GetGameObjectFromSerializedProperty(serializedObject, fieldName, debugInfo);
                     if (foundObject == null)
                     {
                         // 如果通过引用关系找不到，再尝试通过字段名匹配
                         foundObject = FindGameObjectByFieldName(fieldName, typeName, debugInfo);
                     }
                     
                     if (foundObject != null)
                     {
                         if (!objectFieldCounts.ContainsKey(foundObject))
                             objectFieldCounts[foundObject] = 0;
                         objectFieldCounts[foundObject]++;
                     }
                 }
             }
             
             // 输出对象字段统计
             debugInfo.AppendLine($"[ComponentBinder] Object field counts: {string.Join(", ", objectFieldCounts.Select(kvp => $"{kvp.Key.name}:{kvp.Value}"))}");
             
             // 第二遍：按顺序读取字段并创建条目
             var processedFields = new Dictionary<GameObject, int>();
             
             for (int i = regionStart + 1; i < regionEnd; i++)
             {
                 string line = lines[i].Trim();
                 if (string.IsNullOrEmpty(line)) continue;
                 
                 // 解析字段声明 - 支持 [SerializeField] 属性
                 var fieldMatch = Regex.Match(line, @"(?:\[SerializeField\]\s+)?(public|private)\s+(\S+)\s+(\S+);");
                 if (fieldMatch.Success)
                 {
                     string visibility = fieldMatch.Groups[1].Value;
                     string typeName = fieldMatch.Groups[2].Value;
                     string fieldName = fieldMatch.Groups[3].Value;
                     
                     // 优先通过 SerializedProperty 获取引用关系
                     GameObject foundObject = GetGameObjectFromSerializedProperty(serializedObject, fieldName, debugInfo);
                     if (foundObject == null)
                     {
                         // 如果通过引用关系找不到，再尝试通过字段名匹配
                         foundObject = FindGameObjectByFieldName(fieldName, typeName, debugInfo);
                     }
                     
                     if (foundObject != null)
                     {
                         // 为这个对象分配下一个索引
                         if (!processedFields.ContainsKey(foundObject))
                             processedFields[foundObject] = 0;
                         
                         int currentIndex = processedFields[foundObject];
                         processedFields[foundObject]++;
                         
                         debugInfo.AppendLine($"[ComponentBinder] Adding object '{foundObject.name}' with index {currentIndex} for field '{fieldName}'");
                         
                         AddGameObjectToListsWithIndex(foundObject, typeName, visibility == "public", currentIndex);
                     }
                 }
             }
             
             debugInfo.AppendLine($"[ComponentBinder] Final dragTargets count: {dragTargets.Count()}");
             
             // 一次性输出所有调试信息
             Debug.Log(debugInfo.ToString());
         }
        
                 private void LoadSeparateScriptFields()
         {
             string scriptPath = AssetDatabase.GetAssetPath(MonoScript.FromMonoBehaviour(targetScript));
             string scriptDirectory = Path.GetDirectoryName(scriptPath);
             string scriptName = Path.GetFileNameWithoutExtension(scriptPath);
             string holderScriptPath = Path.Combine(scriptDirectory, $"{scriptName}ComponentHolder.cs");
             
             if (!File.Exists(holderScriptPath)) return;
             
             string[] lines = File.ReadAllLines(holderScriptPath);
             
             var debugInfo = new System.Text.StringBuilder();
             debugInfo.AppendLine($"[ComponentBinder] Loading separate script fields from {holderScriptPath}");
             
             // 获取当前脚本的 SerializedObject 来读取引用关系
             var serializedObject = new SerializedObject(targetScript);
             
             // 先统计每个对象有多少个字段，用于正确分配索引
             var objectFieldCounts = new Dictionary<GameObject, int>();
             
             // 第一遍：统计每个对象的字段数量
             foreach (string line in lines)
             {
                 string trimmedLine = line.Trim();
                 if (string.IsNullOrEmpty(trimmedLine)) continue;
                 
                 var fieldMatch = Regex.Match(trimmedLine, @"(?:\[SerializeField\]\s+)?(public|private)\s+(\S+)\s+(\S+);");
                 if (fieldMatch.Success)
                 {
                     string typeName = fieldMatch.Groups[2].Value;
                     string fieldName = fieldMatch.Groups[3].Value;
                     
                     debugInfo.AppendLine($"[ComponentBinder] Found field: {typeName} {fieldName}");
                     
                     // 优先通过 SerializedProperty 获取引用关系
                     GameObject foundObject = GetGameObjectFromSerializedProperty(serializedObject, fieldName, debugInfo);
                     if (foundObject == null)
                     {
                         // 如果通过引用关系找不到，再尝试通过字段名匹配
                         foundObject = FindGameObjectByFieldName(fieldName, typeName, debugInfo);
                     }
                     
                     if (foundObject != null)
                     {
                         if (!objectFieldCounts.ContainsKey(foundObject))
                             objectFieldCounts[foundObject] = 0;
                         objectFieldCounts[foundObject]++;
                     }
                 }
             }
             
             // 输出对象字段统计
             debugInfo.AppendLine($"[ComponentBinder] Object field counts: {string.Join(", ", objectFieldCounts.Select(kvp => $"{kvp.Key.name}:{kvp.Value}"))}");
             
             // 第二遍：按顺序读取字段并创建条目
             var processedFields = new Dictionary<GameObject, int>();
             
             // 读取 ComponentHolder 文件中的字段
             foreach (string line in lines)
             {
                 string trimmedLine = line.Trim();
                 if (string.IsNullOrEmpty(trimmedLine)) continue;
                 
                 // 解析字段声明 - 支持 [SerializeField] 属性
                 var fieldMatch = Regex.Match(trimmedLine, @"(?:\[SerializeField\]\s+)?(public|private)\s+(\S+)\s+(\S+);");
                 if (fieldMatch.Success)
                 {
                     string visibility = fieldMatch.Groups[1].Value;
                     string typeName = fieldMatch.Groups[2].Value;
                     string fieldName = fieldMatch.Groups[3].Value;
                     
                     // 优先通过 SerializedProperty 获取引用关系
                     GameObject foundObject = GetGameObjectFromSerializedProperty(serializedObject, fieldName, debugInfo);
                     if (foundObject == null)
                     {
                         // 如果通过引用关系找不到，再尝试通过字段名匹配
                         foundObject = FindGameObjectByFieldName(fieldName, typeName, debugInfo);
                     }
                     
                     if (foundObject != null)
                     {
                         // 为这个对象分配下一个索引
                         if (!processedFields.ContainsKey(foundObject))
                             processedFields[foundObject] = 0;
                         
                         int currentIndex = processedFields[foundObject];
                         processedFields[foundObject]++;
                         
                         debugInfo.AppendLine($"[ComponentBinder] Adding object '{foundObject.name}' with index {currentIndex} for field '{fieldName}'");
                         
                         AddGameObjectToListsWithIndex(foundObject, typeName, visibility == "public", currentIndex);
                     }
                 }
             }
             
             debugInfo.AppendLine($"[ComponentBinder] Final dragTargets count: {dragTargets.Count()}");
             
             // 一次性输出所有调试信息
             Debug.Log(debugInfo.ToString());
         }
        
        private void AddGameObjectToLists(GameObject foundObject, string typeName, bool isPublic)
        {
            // 计算这个对象已经有多少个条目
            int existingCount = dragTargets.Count(entry => entry.gameObject == foundObject);
            
            // 创建新的条目
            var newEntry = new DragTargetEntry(foundObject, existingCount);
            
            // 添加到现有列表中
            if (!dragTargets.Contains(newEntry))
            {
                dragTargets.Add(newEntry);
            }
            
            // 设置重命名
            if (!renameMap.ContainsKey(newEntry))
            {
                renameMap[newEntry] = ToPascalCase(foundObject.name);
            }
            
            // 设置组件映射
            if (!componentMap.ContainsKey(newEntry))
            {
                var comps = foundObject.GetComponents<Component>().Where(c => c != null).ToList();
                if (!comps.Any(c => c is Transform))
                    comps.Add(foundObject.transform);
                comps.Add(new GameObjectProxy(foundObject));
                
                componentMap[newEntry] = comps.OrderBy(c =>
                {
                    if (c is GameObjectProxy) return 3;
                    if (c is Transform) return 2;
                    return 0;
                }).ToList();
            }
            
            // 设置选中的组件索引
            if (!selectedIndices.ContainsKey(newEntry))
            {
                var targetType = GetComponentTypeFromName(typeName);
                var index = componentMap[newEntry].FindIndex(c => 
                    c.GetType().Name == targetType || 
                    (targetType == "TMP_Text" && c.GetType().Name.Contains("TextMeshPro")) ||
                    (targetType == "GameObject" && c is GameObjectProxy));
                selectedIndices[newEntry] = index >= 0 ? index : 0;
            }
            
            // 设置字段可见性
            if (!fieldVisibilityMap.ContainsKey(newEntry))
            {
                fieldVisibilityMap[newEntry] = isPublic;
            }
        }
        
        private void AddGameObjectToListsWithIndex(GameObject foundObject, string typeName, bool isPublic, int specifiedIndex)
        {
            // 创建新的条目，使用指定的索引
            var newEntry = new DragTargetEntry(foundObject, specifiedIndex);
            
            // 直接添加到现有列表中（允许重复的对象条目）
            dragTargets.Add(newEntry);
            
            // 设置重命名
            renameMap[newEntry] = ToPascalCase(foundObject.name);
            
            // 设置组件映射
            var comps = foundObject.GetComponents<Component>().Where(c => c != null).ToList();
            if (!comps.Any(c => c is Transform))
                comps.Add(foundObject.transform);
            comps.Add(new GameObjectProxy(foundObject));
            
            componentMap[newEntry] = comps.OrderBy(c =>
            {
                if (c is GameObjectProxy) return 3;
                if (c is Transform) return 2;
                return 0;
            }).ToList();
            
            // 设置选中的组件索引
            var targetType = GetComponentTypeFromName(typeName);
            var index = componentMap[newEntry].FindIndex(c => 
                c.GetType().Name == targetType || 
                (targetType == "TMP_Text" && c.GetType().Name.Contains("TextMeshPro")) ||
                (targetType == "GameObject" && c is GameObjectProxy));
            selectedIndices[newEntry] = index >= 0 ? index : 0;
            
            // 设置字段可见性
            fieldVisibilityMap[newEntry] = isPublic;
        }
        
                 private GameObject FindGameObjectByFieldName(string fieldName, string typeName, System.Text.StringBuilder debugInfo = null)
         {
             // 尝试在场景中找到匹配的 GameObject
             var allObjects = UnityEngine.Object.FindObjectsOfType<GameObject>();
             
             if (debugInfo != null)
             {
                 debugInfo.AppendLine($"[ComponentBinder] Searching for field '{fieldName}' of type '{typeName}'");
                 debugInfo.AppendLine($"[ComponentBinder] Available objects: {string.Join(", ", allObjects.Select(o => o.name))}");
             }
             
             // 策略1: 首先尝试解析 对象名_组件名 格式的字段名
             if (fieldName.Contains("_"))
             {
                 string[] parts = fieldName.Split('_');
                 if (parts.Length >= 2)
                 {
                     string objectName = parts[0];
                     string componentName = parts[1];
                     
                     if (debugInfo != null)
                         debugInfo.AppendLine($"[ComponentBinder] Parsed field name: object='{objectName}', component='{componentName}'");
                     
                     // 将 camelCase 转换为 PascalCase 来匹配对象名
                     string pascalObjectName = char.ToUpperInvariant(objectName[0]) + objectName.Substring(1);
                     
                     if (debugInfo != null)
                         debugInfo.AppendLine($"[ComponentBinder] Pascal object name: '{pascalObjectName}'");
                     
                     // 查找所有匹配名称的对象
                     var matchingObjects = allObjects.Where(obj => 
                         obj.name == pascalObjectName).ToList();
                     
                     if (matchingObjects.Count() == 1)
                     {
                         if (debugInfo != null)
                             debugInfo.AppendLine($"[ComponentBinder] Found single object '{matchingObjects[0].name}' for field '{fieldName}'");
                         return matchingObjects[0];
                     }
                     else if (matchingObjects.Count() > 1)
                     {
                         if (debugInfo != null)
                             debugInfo.AppendLine($"[ComponentBinder] Found {matchingObjects.Count()} objects with name '{pascalObjectName}', trying component-based matching");
                         
                         // 如果有多个同名对象，尝试通过组件类型来区分
                         var targetComponentType1 = GetComponentTypeFromName(typeName);
                         foreach (var obj in matchingObjects)
                         {
                             var component = obj.GetComponent(targetComponentType1);
                             if (component != null)
                             {
                                 if (debugInfo != null)
                                     debugInfo.AppendLine($"[ComponentBinder] Found object '{obj.name}' with component '{targetComponentType1}' for field '{fieldName}'");
                                 return obj;
                             }
                         }
                         
                         if (debugInfo != null)
                             debugInfo.AppendLine($"[ComponentBinder] No object with component '{targetComponentType1}' found among objects named '{pascalObjectName}'");
                     }
                     else
                     {
                         if (debugInfo != null)
                             debugInfo.AppendLine($"[ComponentBinder] No object found with name '{pascalObjectName}' for field '{fieldName}'");
                     }
                 }
             }
             
             // 策略2: 尝试通过组件类型匹配（适用于没有明确对象名的情况）
             var targetComponentType = GetComponentTypeFromName(typeName);
             var objectsWithComponent = allObjects.Where(obj => 
                 obj.GetComponent(targetComponentType) != null).ToList();
             
             if (debugInfo != null)
                 debugInfo.AppendLine($"[ComponentBinder] Found {objectsWithComponent.Count()} objects with component '{targetComponentType}'");
             
             if (objectsWithComponent.Count() == 1)
             {
                 if (debugInfo != null)
                     debugInfo.AppendLine($"[ComponentBinder] Found single object '{objectsWithComponent[0].name}' with component '{targetComponentType}' for field '{fieldName}'");
                 return objectsWithComponent[0];
             }
             else if (objectsWithComponent.Count() > 1)
             {
                 if (debugInfo != null)
                     debugInfo.AppendLine($"[ComponentBinder] Multiple objects with component '{targetComponentType}', trying name-based matching");
                 
                 // 如果有多个对象都有该组件，尝试通过字段名来匹配
                 foreach (var obj in objectsWithComponent)
                 {
                     string camelName = Char.ToLowerInvariant(obj.name[0]) + obj.name.Substring(1);
                     
                     // 直接匹配字段名
                     if (fieldName == camelName)
                     {
                         if (debugInfo != null)
                             debugInfo.AppendLine($"[ComponentBinder] Found object '{obj.name}' by name match for field '{fieldName}'");
                         return obj;
                     }
                     
                     // 匹配带类型后缀的字段名
                     if (fieldName == camelName + typeName)
                     {
                         if (debugInfo != null)
                             debugInfo.AppendLine($"[ComponentBinder] Found object '{obj.name}' by name+type match for field '{fieldName}'");
                         return obj;
                     }
                     
                     // 匹配带数字后缀的字段名（如 "他的1"）
                     if (fieldName.StartsWith(camelName) && fieldName.Length > camelName.Length)
                     {
                         string suffix = fieldName.Substring(camelName.Length);
                         if (suffix.All(char.IsDigit))
                         {
                             if (debugInfo != null)
                                 debugInfo.AppendLine($"[ComponentBinder] Found object '{obj.name}' by name+number match for field '{fieldName}'");
                             return obj;
                         }
                     }
                 }
             }
             
             // 策略3: 最后的兜底策略 - 尝试所有可能的匹配方式
             foreach (var obj in allObjects)
             {
                 
                 string camelName = Char.ToLowerInvariant(obj.name[0]) + obj.name.Substring(1);
                 
                 // 直接匹配字段名
                 if (fieldName == camelName)
                 {
                     if (debugInfo != null)
                         debugInfo.AppendLine($"[ComponentBinder] Found object '{obj.name}' by fallback name match for field '{fieldName}'");
                     return obj;
                 }
                 
                 // 匹配带类型后缀的字段名
                 if (fieldName == camelName + typeName)
                 {
                     if (debugInfo != null)
                         debugInfo.AppendLine($"[ComponentBinder] Found object '{obj.name}' by fallback name+type match for field '{fieldName}'");
                     return obj;
                 }
                 
                 // 匹配带类型后缀的字段名（去掉类型名中的空格等）
                 string cleanTypeName = typeName.Replace(" ", "").Replace("_", "");
                 if (fieldName == camelName + cleanTypeName)
                 {
                     if (debugInfo != null)
                         debugInfo.AppendLine($"[ComponentBinder] Found object '{obj.name}' by fallback name+cleanType match for field '{fieldName}'");
                     return obj;
                 }
                 
                 // 匹配带类型后缀和数字后缀的字段名（如 "他的Transform1"）
                 if (fieldName.StartsWith(camelName + typeName) && fieldName.Length > camelName.Length + typeName.Length)
                 {
                     string suffix = fieldName.Substring(camelName.Length + typeName.Length);
                     if (suffix.All(char.IsDigit))
                     {
                         if (debugInfo != null)
                             debugInfo.AppendLine($"[ComponentBinder] Found object '{obj.name}' by fallback name+type+number match for field '{fieldName}'");
                         return obj;
                     }
                 }
             }
             
             if (debugInfo != null)
                 debugInfo.AppendLine($"[ComponentBinder] No object found for field '{fieldName}' after trying all strategies");
             
             return null;
         }
        
        private string GetComponentTypeFromName(string typeName)
        {
            // 将类型名转换回组件类型名
            switch (typeName)
            {
                case "TMP_Text": return "TextMeshProUGUI";
                case "GameObject": return "GameObject";
                case "Transform": return "Transform";
                case "Text": return "Text";
                case "Button": return "Button";
                case "Image": return "Image";
                case "Slider": return "Slider";
                case "InputField": return "InputField";
                case "ScrollRect": return "ScrollRect";
                case "Toggle": return "Toggle";
                case "Dropdown": return "Dropdown";
                case "RawImage": return "RawImage";
                case "Mask": return "Mask";
                case "RectMask2D": return "RectMask2D";
                case "Canvas": return "Canvas";
                case "CanvasGroup": return "CanvasGroup";
                case "CanvasScaler": return "CanvasScaler";
                case "GraphicRaycaster": return "GraphicRaycaster";
                case "Renderer": return "Renderer";
                case "MeshRenderer": return "MeshRenderer";
                case "SkinnedMeshRenderer": return "SkinnedMeshRenderer";
                case "Collider": return "Collider";
                case "BoxCollider": return "BoxCollider";
                case "SphereCollider": return "SphereCollider";
                case "CapsuleCollider": return "CapsuleCollider";
                case "MeshCollider": return "MeshCollider";
                case "Rigidbody": return "Rigidbody";
                case "Rigidbody2D": return "Rigidbody2D";
                case "Collider2D": return "Collider2D";
                case "BoxCollider2D": return "BoxCollider2D";
                case "CircleCollider2D": return "CircleCollider2D";
                case "CapsuleCollider2D": return "CapsuleCollider2D";
                case "PolygonCollider2D": return "PolygonCollider2D";
                case "EdgeCollider2D": return "EdgeCollider2D";
                case "AudioSource": return "AudioSource";
                case "AudioListener": return "AudioListener";
                case "Camera": return "Camera";
                case "Light": return "Light";
                case "ParticleSystem": return "ParticleSystem";
                case "Animator": return "Animator";
                case "Animation": return "Animation";
                case "LineRenderer": return "LineRenderer";
                case "TrailRenderer": return "TrailRenderer";
                case "Terrain": return "Terrain";
                case "WindZone": return "WindZone";
                case "LensFlare": return "LensFlare";
                case "Halo": return "Halo";
                case "Projector": return "Projector";
                case "ReflectionProbe": return "ReflectionProbe";
                case "LightProbeGroup": return "LightProbeGroup";
                case "OcclusionArea": return "OcclusionArea";
                case "OcclusionPortal": return "OcclusionPortal";
                case "LODGroup": return "LODGroup";
                case "NavMeshAgent": return "NavMeshAgent";
                case "NavMeshObstacle": return "NavMeshObstacle";
                case "OffMeshLink": return "OffMeshLink";
                case "Cloth": return "Cloth";
                case "HingeJoint": return "HingeJoint";
                case "SpringJoint": return "SpringJoint";
                case "FixedJoint": return "FixedJoint";
                case "CharacterJoint": return "CharacterJoint";
                case "ConfigurableJoint": return "ConfigurableJoint";
                case "ConstantForce": return "ConstantForce";
                case "ConstantForce2D": return "ConstantForce2D";
                case "AreaEffector2D": return "AreaEffector2D";
                case "PointEffector2D": return "PointEffector2D";
                case "PlatformEffector2D": return "PlatformEffector2D";
                case "SurfaceEffector2D": return "SurfaceEffector2D";
                case "BuoyancyEffector2D": return "BuoyancyEffector2D";
                case "RelativeJoint2D": return "RelativeJoint2D";
                case "FrictionJoint2D": return "FrictionJoint2D";
                case "TargetJoint2D": return "TargetJoint2D";
                case "MotorJoint2D": return "MotorJoint2D";
                case "SliderJoint2D": return "SliderJoint2D";
                case "HingeJoint2D": return "HingeJoint2D";
                case "SpringJoint2D": return "SpringJoint2D";
                case "DistanceJoint2D": return "DistanceJoint2D";
                case "WheelJoint2D": return "WheelJoint2D";
                case "FixedJoint2D": return "FixedJoint2D";
                default: return typeName;
            }
        }

        private void CreateSeparateComponentHolder()
        {
            string scriptPath = AssetDatabase.GetAssetPath(MonoScript.FromMonoBehaviour(targetScript));
            string scriptDirectory = Path.GetDirectoryName(scriptPath);
            string scriptName = Path.GetFileNameWithoutExtension(scriptPath);
            string holderScriptPath = Path.Combine(scriptDirectory, $"{scriptName}ComponentHolder.cs");
            
            // 生成组件持有者脚本内容
            var scriptContent = GenerateComponentHolderScript(scriptName, holderScriptPath);
            
            // 写入文件
            File.WriteAllText(holderScriptPath, scriptContent);
            
            // 在原脚本中添加 partial 关键字和组件持有者引用
            AddPartialClassAndComponentHolderReference(scriptPath, scriptName);
            
            AssetDatabase.Refresh();
            
            Debug.Log($"Component holder script created: {holderScriptPath}");
        }
        
        private string GenerateComponentHolderScript(string originalScriptName, string holderScriptPath)
        {
            var scriptBuilder = new System.Text.StringBuilder();
            
            // 重新生成字段
            var pendingList = new AutoBindingEntryList();
            cachedExistingFields.Clear();
            
            // 收集所有字段信息用于生成using语句
            var newFields = new List<string>();
            
            // 使用索引来遍历，这样可以保持顺序并处理重复的对象
            for (int i = 0; i < dragTargets.Count(); i++)
            {
                var entry = dragTargets[i];
                string baseName = renameMap.ContainsKey(entry) ? renameMap[entry] : entry.gameObject.name;
                string camelName = Char.ToLowerInvariant(baseName[0]) + baseName.Substring(1);
                var targetsToBind = new List<Component> { componentMap[entry][selectedIndices[entry]] };

                 foreach (var comp in targetsToBind)
                 {
                     if (comp is GameObjectProxy proxy)
                     {
                       
                         
                         // 使用 对象名_组件名 的命名策略
                         string varName1 = camelName + "_GameObject";
                         
                         // 如果还是冲突，添加数字后缀
                         int suffix1 = 1;
                         string originalVarName1 = varName1;
                         while (cachedExistingFields.Contains(varName1))
                         {
                             varName1 = originalVarName1 + suffix1.ToString();
                             suffix1++;
                         }
                         
                         bool isPublic2 = fieldVisibilityMap.ContainsKey(entry) ? fieldVisibilityMap[entry] : false;
                         string visibility2 = isPublic2 ? "public" : "private";
                         string attribute2 = isPublic2 ? "" : "[SerializeField] ";
                         newFields.Add($"{attribute2}{visibility2} GameObject {varName1};");
                         cachedExistingFields.Add(varName1);
                         
                         pendingList.list.Add(new AutoBindingEntry
                         {
                             scriptPath = holderScriptPath,
                             fieldName = varName1,
                             targetInstanceId = targetScript.GetInstanceID(),
                             componentInstanceId = proxy.gameObjectRef.GetInstanceID()
                         });
                         continue;
                     }

                     if (comp == null) continue;
                    
                     string typeName = comp.GetType().Name.Contains("TextMeshProUGUI") ? "TMP_Text" : comp.GetType().Name.Replace("Proxy", "");
                     string varName=  GenerateFinalFieldName(camelName, typeName, cachedExistingFields);
                     /*// 使用 对象名_组件名 的命名策略
                     string varName = camelName + "_" + typeName;

                     // 如果还是冲突，添加数字后缀
                     int suffix = 1;
                     string originalVarName = varName;
                     while (cachedExistingFields.Contains(varName))
                     {
                         varName = originalVarName + suffix.ToString();
                         suffix++;
                     }*/

                     bool isPublic1 = fieldVisibilityMap.ContainsKey(entry) ? fieldVisibilityMap[entry] : false;
                     string visibility1 = isPublic1 ? "public" : "private";
                     string attribute1 = isPublic1 ? "" : "[SerializeField] ";
                     newFields.Add($"{attribute1}{visibility1} {typeName} {varName};");
                     cachedExistingFields.Add(varName);
                     
                     pendingList.list.Add(new AutoBindingEntry
                     {
                         scriptPath = holderScriptPath,
                         fieldName = varName,
                         targetInstanceId = targetScript.GetInstanceID(),
                         componentInstanceId = comp.GetInstanceID()
                     });
                 }
            }
            
            // 生成using语句
            var usingStatements = new List<string>();
            usingStatements.Add("using UnityEngine;");
            
            // 使用AddRequiredUsingStatements的逻辑来添加必要的using语句
            if (newFields.Any(field => field.Contains("TMP_Text") || field.Contains("TextMeshPro")))
            {
                usingStatements.Add("using TMPro;");
            }
            if (newFields.Any(field => field.Contains("Button") || field.Contains("Image") || field.Contains("Text") || field.Contains("Canvas") || field.Contains("RectTransform")))
            {
                usingStatements.Add("using UnityEngine.UI;");
            }
            if (newFields.Any(field => field.Contains("EventSystem") || field.Contains("PointerEventData")))
            {
                usingStatements.Add("using UnityEngine.EventSystems;");
            }
            if (newFields.Any(field => field.Contains("List<") || field.Contains("Dictionary<")))
            {
                usingStatements.Add("using System.Collections.Generic;");
            }
            if (newFields.Any(field => field.Contains("Action") || field.Contains("Func<")))
            {
                usingStatements.Add("using System;");
            }
            
            // 添加using语句到脚本
            foreach (var usingStatement in usingStatements)
            {
                scriptBuilder.AppendLine(usingStatement);
            }
            scriptBuilder.AppendLine();
            
            // 类定义 - 使用 partial 类
            scriptBuilder.AppendLine($"/// <summary>");
            scriptBuilder.AppendLine($"/// Component holder for {originalScriptName}");
            scriptBuilder.AppendLine($"/// Auto-generated by Component Binder");
            scriptBuilder.AppendLine($"/// </summary>");
            scriptBuilder.AppendLine($"[System.Serializable]");
            scriptBuilder.AppendLine($"public partial class {originalScriptName} : MonoBehaviour");
            scriptBuilder.AppendLine("{");
            
            // 添加字段到脚本
            foreach (var field in newFields)
            {
                scriptBuilder.AppendLine($"    {field}");
            }
            
            scriptBuilder.AppendLine("}");
            
            // 保存绑定信息
            EditorPrefs.SetString("ComponentBinder_AutoBindings", JsonUtility.ToJson(pendingList));
            
            return scriptBuilder.ToString();
        }
        
        private void AddPartialClassAndComponentHolderReference(string scriptPath, string scriptName)
        {
            string[] lines = File.ReadAllLines(scriptPath);
            var fieldLines = new List<string>(lines);
            
            // 查找类的开始位置并添加 partial 关键字
            int classStartIndex = fieldLines.FindIndex(l => l.Contains("class") && l.Contains(":"));
            if (classStartIndex != -1)
            {
                string classLine = fieldLines[classStartIndex];
                if (!classLine.Contains("partial"))
                {
                    // 在 class 关键字前添加 partial
                    classLine = classLine.Replace("public class", "public partial class");
                    classLine = classLine.Replace("private class", "private partial class");
                    classLine = classLine.Replace("internal class", "internal partial class");
                    fieldLines[classStartIndex] = classLine;
                }
            }
            
            File.WriteAllLines(scriptPath, fieldLines);
        }

        private void AddRequiredUsingStatements(List<string> fieldLines, List<string> newFields)
        {
            var requiredUsings = new List<string>();
            
            // 检查是否需要添加 using 语句
            if (!fieldLines.Any(line => line.Contains("using TMPro")) && newFields.Any(f => f.Contains("TMP_")))
            {
                requiredUsings.Add("using TMPro;");
            }
            
            if (!fieldLines.Any(line => line.Contains("using System.Collections.Generic")) && newFields.Any(f => f.Contains("List<")))
            {
                requiredUsings.Add("using System.Collections.Generic;");
            }
            
            // 检查其他常用的 Unity 命名空间
            if (!fieldLines.Any(line => line.Contains("using UnityEngine.UI")) && newFields.Any(f => f.Contains("Button") || f.Contains("Text") || f.Contains("Image") || f.Contains("Slider")))
            {
                requiredUsings.Add("using UnityEngine.UI;");
            }
            
            if (!fieldLines.Any(line => line.Contains("using UnityEngine.Events")) && newFields.Any(f => f.Contains("UnityEvent")))
            {
                requiredUsings.Add("using UnityEngine.Events;");
            }
            
            if (!fieldLines.Any(line => line.Contains("using System")) && newFields.Any(f => f.Contains("Action") || f.Contains("Func<")))
            {
                requiredUsings.Add("using System;");
            }
            
            // 添加 using 语句到文件中
            if (requiredUsings.Count() > 0)
            {
                int usingIndex = fieldLines.FindLastIndex(l => l.StartsWith("using"));
                if (usingIndex == -1)
                {
                    // 如果没有 using 语句，在文件开头添加
                    usingIndex = 0;
                }
                
                foreach (var usingStatement in requiredUsings)
                {
                    fieldLines.Insert(usingIndex + 1, usingStatement);
                    usingIndex++;
                }
            }
        }

                 private GameObject GetGameObjectFromSerializedProperty(SerializedObject serializedObject, string fieldName, System.Text.StringBuilder debugInfo = null)
         {
             try
             {
                 // 查找字段对应的 SerializedProperty
                 var property = serializedObject.FindProperty(fieldName);
                 if (property != null && property.objectReferenceValue != null)
                 {
                     if (debugInfo != null)
                         debugInfo.AppendLine($"[ComponentBinder] Found reference for field '{fieldName}': {property.objectReferenceValue.name}");
                     
                     // 如果引用的是 GameObject，直接返回
                     if (property.objectReferenceValue is GameObject go)
                     {
                         if (debugInfo != null)
                             debugInfo.AppendLine($"[ComponentBinder] Field '{fieldName}' references GameObject '{go.name}'");
                         return go;
                     }
                     
                     // 如果引用的是 Component，返回其所属的 GameObject
                     if (property.objectReferenceValue is Component component)
                     {
                         if (debugInfo != null)
                             debugInfo.AppendLine($"[ComponentBinder] Field '{fieldName}' references Component '{component.name}' on GameObject '{component.gameObject.name}'");
                         return component.gameObject;
                     }
                 }
                 else
                 {
                     if (debugInfo != null)
                         debugInfo.AppendLine($"[ComponentBinder] No reference found for field '{fieldName}'");
                 }
             }
             catch (System.Exception ex)
             {
                 if (debugInfo != null)
                     debugInfo.AppendLine($"[ComponentBinder] Error reading reference for field '{fieldName}': {ex.Message}");
             }
             
             return null;
         }
         
         private string ToPascalCase(string input)
         {
             if (string.IsNullOrEmpty(input)) return input;
             string cleaned = new string(input.Where(c => char.IsLetterOrDigit(c) || c == ' ' || c == '_').ToArray());
             string[] parts = cleaned.Split(new[] { '_', ' ' }, StringSplitOptions.RemoveEmptyEntries);
             return string.Concat(parts.Select(p => char.ToUpperInvariant(p[0]) + p.Substring(1)));
         }

         /// <summary>
         /// 根据组件类型获取其在下拉列表中的显示优先级。
         /// 数字越小，优先级越高。
         /// </summary>
         /// <param name="component">要评估的组件</param>
         /// <returns>优先级对应的整数</returns>
         private int GetComponentPriority(Component component)
         {
             // 交互类组件，优先级最高
             if (component is UnityEngine.UI.Button) return -10;
             if (component is TMPro.TMP_InputField || component is UnityEngine.UI.InputField) return -9;
             if (component is UnityEngine.UI.Toggle) return -8;
             if (component is UnityEngine.UI.Slider) return -7;
             if (component is TMPro.TMP_Dropdown || component is UnityEngine.UI.Dropdown) return -6;
             if (component is UnityEngine.UI.ScrollRect) return -5;
             if (component is UnityEngine.UI.Scrollbar) return -4;

             // 显示类组件，优先级次之
             if (component is UnityEngine.UI.Image) return -3;
             if (component is UnityEngine.UI.RawImage) return -2;
             if (component is TMPro.TextMeshProUGUI || component is UnityEngine.UI.Text) return -1;

             // 特殊处理的类型，保持原有逻辑
             if (component is GameObjectProxy) return 3;
             if (component is Transform) return 2;

             // 其他所有组件的默认优先级
             return 0;
         }
         /// <summary>
         /// 根据基础名称和组件类型，生成最终的、唯一的C#字段名。
         /// 这里处理命名规则,默认是对象名_组件名的形式。这里可以自定义规则
         /// </summary>
         /// <param name="baseName">UI上定义的名称</param>
         /// <param name="componentType">要绑定的组件名</param>
         /// <returns>唯一的字段名</returns>
         private string GenerateFinalFieldName(string baseName, string componentType,HashSet<string> existingNames)
         {
             // 使用 对象名_组件名 的命名策略   自定义规则就改这里
             string varName = baseName + "_" + componentType;

             // 如果还是冲突，添加数字后缀
             int suffix = 1;
             string originalVarName = varName;
             while (existingNames.Contains(varName))
             {
                 varName = originalVarName + suffix.ToString();
                 suffix++;
             }
             return varName;
         }
        private void UpdateNamespace(List<string> lines)
        {
            // 查找现有命名空间
            int namespaceLineIndex = -1;
            string existingNamespace = "";
            
            for (int i = 0; i < lines.Count; i++)
            {
                var match = Regex.Match(lines[i], @"^\s*namespace\s+(\S+)");
                if (match.Success)
                {
                    namespaceLineIndex = i;
                    existingNamespace = match.Groups[1].Value;
                    break;
                }
            }
            
            // 情况1: 现有命名空间与目标一致 -> 不做任何事
            if (existingNamespace == currentNamespace) return;
            
            // 情况2: 目标为空 -> 移除现有命名空间
            if (string.IsNullOrEmpty(currentNamespace))
            {
                if (namespaceLineIndex != -1)
                {
                    // 移除 namespace 行
                    lines.RemoveAt(namespaceLineIndex);
                    
                    // 移除紧随其后的 {
                    if (namespaceLineIndex < lines.Count && lines[namespaceLineIndex].Trim() == "{")
                    {
                        lines.RemoveAt(namespaceLineIndex);
                    }
                    
                    // 移除最后的 }
                    for (int i = lines.Count - 1; i >= 0; i--)
                    {
                        if (lines[i].Trim() == "}")
                        {
                            lines.RemoveAt(i);
                            break;
                        }
                    }
                }
            }
            // 情况3: 原来没有，现在有了 -> 添加并包裹
            else if (namespaceLineIndex == -1)
            {
                // 找到插入点 (using 之后)
                int insertIndex = 0;
                for (int i = 0; i < lines.Count; i++)
                {
                    if (lines[i].Trim().StartsWith("using ") || string.IsNullOrWhiteSpace(lines[i]))
                        insertIndex = i + 1;
                    else
                        break;
                }
                
                if (insertIndex > lines.Count) insertIndex = lines.Count;
                
                lines.Insert(insertIndex, "");
                lines.Insert(insertIndex + 1, $"namespace {currentNamespace}");
                lines.Insert(insertIndex + 2, "{");
                lines.Add("}");
            }
            // 情况4: 原来有，现在变了 -> 直接修改名称
            else
            {
                lines[namespaceLineIndex] = lines[namespaceLineIndex].Replace(existingNamespace, currentNamespace);
            }
        }
    }

    [Serializable]
    public class DragTargetEntry
    {
        public GameObject gameObject;
        public int instanceId;
        public int entryIndex; // 用于区分同一个对象的多个条目
        
        public DragTargetEntry(GameObject go, int index = 0)
        {
            gameObject = go;
            instanceId = go.GetInstanceID();
            entryIndex = index;
        }
        
        public override bool Equals(object obj)
        {
            if (obj is DragTargetEntry other)
            {
                return instanceId == other.instanceId && entryIndex == other.entryIndex;
            }
            return false;
        }
        
        public override int GetHashCode()
        {
            return HashCode.Combine(instanceId, entryIndex);
        }
        
        public override string ToString()
        {
            return $"{gameObject.name}_{entryIndex}";
        }
    }

    public class GameObjectProxy : Component
    {
        public GameObject gameObjectRef;
        public GameObjectProxy(GameObject go) => gameObjectRef = go;
        public override string ToString() => "GameObject";
    }

    [Serializable]
    public class AutoBindingEntry
    {
        public string scriptPath;
        public string fieldName;
        public int targetInstanceId;
        public int componentInstanceId;
    }

    [Serializable]
    public class AutoBindingEntryList
    {
        public List<AutoBindingEntry> list = new();
    }

    [InitializeOnLoad]
    public static class ComponentBinderPostProcessor
    {
        static ComponentBinderPostProcessor()
        {
            EditorApplication.delayCall += TryBind;
        }

        static void TryBind()
        {
            if (!EditorPrefs.HasKey("ComponentBinder_AutoBindings")) return;

            var json = EditorPrefs.GetString("ComponentBinder_AutoBindings");
            var entries = JsonUtility.FromJson<AutoBindingEntryList>(json);

            foreach (var entry in entries.list)
            {
                var target = EditorUtility.InstanceIDToObject(entry.targetInstanceId) as MonoBehaviour;
                var obj = EditorUtility.InstanceIDToObject(entry.componentInstanceId);

                if (target == null || obj == null) continue;

                var so = new SerializedObject(target);
                var sp = so.FindProperty(entry.fieldName);
                if (sp != null)
                {
                    if (obj is GameObject go)
                        sp.objectReferenceValue = go;
                    else if (obj is Component comp)
                        sp.objectReferenceValue = comp;

                    so.ApplyModifiedProperties();
                }
            }

            EditorPrefs.DeleteKey("ComponentBinder_AutoBindings");
        }
    }

} 